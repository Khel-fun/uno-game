{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"16764836153106980492","abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"old_consumed_hash","type":{"kind":"field"},"visibility":"public"},{"name":"new_consumed_hash","type":{"kind":"field"},"visibility":"public"},{"name":"old_consumed_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"new_consumed_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"card_uid","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"struct","path":"zk_uno::types::MerkleProof","fields":[{"name":"path","type":{"kind":"array","length":7,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":1}}}]},"visibility":"private"},{"name":"old_consumed_bits","type":{"kind":"array","length":108,"type":{"kind":"integer","sign":"unsigned","width":1}},"visibility":"private"},{"name":"new_consumed_bits","type":{"kind":"array","length":108,"type":{"kind":"integer","sign":"unsigned","width":1}},"visibility":"private"}],"return_type":null,"error_types":{"1333969638659434033":{"error_kind":"string","string":"Draw position out of range"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6088141534046202526":{"error_kind":"string","string":"New bitset hash mismatch"},"7239749888204395624":{"error_kind":"string","string":"Position already consumed"},"9134801329391966424":{"error_kind":"string","string":"Invalid consumed count"},"9966601608357917525":{"error_kind":"string","string":"Unexpected bit change"},"10609339108140391171":{"error_kind":"string","string":"Old bitset hash mismatch"},"12504151944586406243":{"error_kind":"string","string":"Invalid Merkle proof"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18399946032034076505":{"error_kind":"string","string":"Position not marked as consumed"}}},"bytecode":"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","debug_symbols":"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xsk0Mp3MIDPJBJkkA9kgG2SDbJANskE2yAbZIBvkm4OxgqPO4c6lRqaTGWQmmSCTZI4djHbsYDTIDXKD3CA3yA1yg9wgN8gdcofcIXfIHXKH3CF3yB1yhzwgD8gD8s3BVahBnQd1HtR5UOdBnQd1nuzgZAcnOzjZwQl5Qp6QJ+QJeUIOyAE5IAfkgByQA3JADsgBOSEn5ISckBNyQr45uAqV1DmpM30w6INBHwz6YNAHgz4Y9MGgDwZ9MOiDQR9M+mDSB5M+mPTBpA8mfTDpg0kfTPpg0geTPph2dKtcDubtUlsfBa+gkxlk5vqQdwXBpeRSHZnl4C2zHLzd7JAdskN2yA7ZITtkh9wgN8gNcoPcIDfIDXKD3CA3yB1yh7wczFpBW1+8XkFfX1lawU6u21M7eX0/PJeDNVaQBHUEy8Fa5OXgS8YJGkHnnkFmEkBeDr7cA3k5+BJAXg7e7pmQl4MvAeTl4Ms9kCdznpCDOQfkYM4BOZhzQA7mHJCDOQfkZM4JOZlzQk7mnJCTOSfkZM4JuZhzQS7mXJCLORfkYs4FuZhzHeTaNgIjOOZcWyPTCQbB5J4gkwSQ7ZhzGWRzAsjWuQeyTQLIltwD2ZmzQ3bm7JCdOTtkZ84O2ZmzQ27MuUFuzLlBbsy5QW7MuUFuzLlB7sy5Q+7MuUPuzLlD7swZBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsHCwcLBwsH918LbopM0THtPWrKdUVD0dR9oVwq0hjouEcaAyH3SGOg5B5pDKTcI42BlnukMVzrcI3hWodrDNc6XGO41uEaw7UO1xhN62gao2kdTWM0raNpjKZ1NI3RtI6mMbrW0TVG1zq6xuhaR9cYXevoGqNrHV1jDK1jaIyhdQyNMbSOoTGG1jE0xtA6hsaYWsfUGFPrmBpjah1TY0ytY2qMqXVMjRFaR2iM0DpCY4TWERojtI7QGKF1hMZIrSM1RmodqTFS60iNkVpHaozUOlJjlNZRGqO0jtIYpXWUxiitozRGaR3y3OS5yXOT5ybPTZ6bPDd5bvLc5LnJc5PnJs9Nnps8N3lu8tzkuclzk+cmz02emzw3eW7y3OS5yXOT5ybPTZ6bPDd5bvLc5LnJc5PnJs9Nnps8N3lu8tzkuclzk+cmz02emzw3eW7y3OS5yXOT5ybPTZ6bPDd5bvLc5LnJc5PnJs9Nnps8N3lu8tzkuclzk+cmz02emzw3eW7y3OS5yXOT5ybPTZ6bPDd5bvLc5LnJc5PnJs9Nnps8N3lu8tzkuclzk+cmz02emzw3eW7y3OS5yXOT5ybPXZ67PHd57vLc5bnLc5fnLs9dnrs8d3nu8tzluctzl+cuz12euzx3ee7y3OW5y3OX5y7PXZ67PHd57vLc5bnLc5fnLs9dnrs8d3nu8tzluctzl+cuz12euzx3ee7y3OW5y3OX5y7PXZ67PHd57vLc5bnLc5fnLs9dnrs8d3nu8tzluctzl+cuz12euzx3ee7y3OW5y3OX5y7PXZ67PHd57vLc5bnLc5fnt+8PVazo5vlLtMZY35z9+92n9+9+/vD819Pbf9aXy758/IVvku1//fyfP7nC/znw56c/fnn+9cun5/Wts2/+44H9zx+8v/H68ev6Ztp/AQ==","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// OPTIMIZED Draw operation circuit\r\n// Proves that a player drew a card from the deck correctly\r\n//\r\n// Key optimizations:\r\n// 1. Accept consumed counts as public inputs (avoids 216 iterations)\r\n// 2. Simplified bitset verification function  \r\n// 3. Removed redundant count_consumed_bits helper\r\n\r\nuse dep::zk_uno::types::{DECK_SIZE, MerkleProof};\r\nuse dep::zk_uno::utils::hash::{hash_card_commitment, compress_bitset};\r\nuse dep::zk_uno::utils::merkle::assert_merkle_proof;\r\n\r\n// OPTIMIZED: Simplified consumed state verification\r\n// Verifies that exactly one bit was flipped from 0 to 1 at the specified position\r\nfn verify_bit_flip<let N: u32>(\r\n    old_bits: [u1; N],\r\n    new_bits: [u1; N],\r\n    position: u32\r\n) {\r\n    assert(position < N, \"Position out of range\");\r\n    assert(old_bits[position] == 0, \"Position already consumed\");\r\n    assert(new_bits[position] == 1, \"Position not marked as consumed\");\r\n    \r\n    // Verify all other bits unchanged\r\n    for i in 0..N {\r\n        if i != position {\r\n            assert(old_bits[i] == new_bits[i], \"Unexpected bit change\");\r\n        }\r\n    }\r\n}\r\n\r\n// Main entry point for the circuit - OPTIMIZED\r\nfn main(\r\n    // Public inputs\r\n    merkle_root: pub Field,\r\n    old_consumed_hash: pub Field,\r\n    new_consumed_hash: pub Field,\r\n    old_consumed_count: pub u32,  // OPTIMIZATION: Pass count as public input\r\n    new_consumed_count: pub u32,  // OPTIMIZATION: Pass count as public input\r\n    \r\n    // Private witnesses\r\n    position: u32,\r\n    card_uid: Field,\r\n    nonce: Field,\r\n    merkle_path: MerkleProof,\r\n    old_consumed_bits: [u1; 108],\r\n    new_consumed_bits: [u1; 108]\r\n) {\r\n    // Verify position is in valid range\r\n    assert(position < DECK_SIZE, \"Draw position out of range\");\r\n    \r\n    // Verify the card exists in the deck at the specified position\r\n    let leaf = hash_card_commitment(card_uid, nonce);\r\n    assert_merkle_proof(leaf, merkle_path, merkle_root);\r\n    \r\n    // OPTIMIZED: Verify consumed state hashes match (only 2 compress operations)\r\n    let old_root = compress_bitset(old_consumed_bits);\r\n    assert(old_root == old_consumed_hash, \"Old bitset hash mismatch\");\r\n    \r\n    let new_root = compress_bitset(new_consumed_bits);\r\n    assert(new_root == new_consumed_hash, \"New bitset hash mismatch\");\r\n    \r\n    // Verify single bit flip at position\r\n    verify_bit_flip(old_consumed_bits, new_consumed_bits, position);\r\n    \r\n    // OPTIMIZED: Use provided counts instead of computing in-circuit (saves 216 iterations)\r\n    assert(new_consumed_count == old_consumed_count + 1, \"Invalid consumed count\");\r\n}\r\n\r\n/// Prove that a card was drawn from a valid unconsumed position\r\n/// OPTIMIZED: Accept counts as parameters instead of computing\r\npub fn prove_draw_card<let N: u32>(\r\n    // Public inputs\r\n    merkle_root: Field,\r\n    old_consumed_hash: Field,\r\n    new_consumed_hash: Field,\r\n    old_consumed_count: u32,\r\n    new_consumed_count: u32,\r\n    \r\n    // Private witnesses\r\n    draw_position: u32,\r\n    card_uid: Field,\r\n    nonce: Field,\r\n    merkle_path: MerkleProof,\r\n    old_consumed_bits: [u1; N],\r\n    new_consumed_bits: [u1; N]\r\n) {\r\n    // Verify the card exists in the deck at the specified position\r\n    let leaf = hash_card_commitment(card_uid, nonce);\r\n    assert_merkle_proof(leaf, merkle_path, merkle_root);\r\n    \r\n    // Verify consumed state hashes\r\n    let old_root = compress_bitset(old_consumed_bits);\r\n    assert(old_root == old_consumed_hash, \"Old bitset hash mismatch\");\r\n    \r\n    let new_root = compress_bitset(new_consumed_bits);\r\n    assert(new_root == new_consumed_hash, \"New bitset hash mismatch\");\r\n    \r\n    // Verify bit flip\r\n    verify_bit_flip(old_consumed_bits, new_consumed_bits, draw_position);\r\n    \r\n    // Verify count\r\n    assert(new_consumed_count == old_consumed_count + 1, \"Invalid consumed count\");\r\n}\r\n\r\n/// Simplified draw for testing\r\npub fn prove_simple_draw(\r\n    merkle_root: Field,\r\n    card_uid: Field,\r\n    nonce: Field,\r\n    position: u32,\r\n    merkle_path: MerkleProof\r\n) {\r\n    // Just verify the card is in the deck\r\n    let leaf = hash_card_commitment(card_uid, nonce);\r\n    assert_merkle_proof(leaf, merkle_path, merkle_root);\r\n    \r\n    // Position validation\r\n    assert(position < DECK_SIZE, \"Draw position out of range\");\r\n}\r\n\r\n/// Prove multiple draws (e.g., draw 2 or draw 4)\r\n/// OPTIMIZED: Accept counts as parameters and use forward-only uniqueness checking\r\npub fn prove_multiple_draws<let K: u32, let N: u32>(\r\n    merkle_root: Field,\r\n    _old_consumed_hash: Field,\r\n    _new_consumed_hash: Field,\r\n    old_consumed_count: u32,\r\n    new_consumed_count: u32,\r\n    positions: [u32; K],\r\n    card_uids: [Field; K],\r\n    nonces: [Field; K],\r\n    merkle_paths: [MerkleProof; K],\r\n    _old_consumed_bits: [u1; N],\r\n    _new_consumed_bits: [u1; N]\r\n) {\r\n    // Verify all cards are valid\r\n    for i in 0..K {\r\n        let leaf = hash_card_commitment(card_uids[i], nonces[i]);\r\n        assert_merkle_proof(leaf, merkle_paths[i], merkle_root);\r\n    }\r\n    \r\n    // OPTIMIZED: Verify positions are unique using forward-only checking\r\n    // This reduces comparisons from K^2 to K^2/2\r\n    for i in 0..K {\r\n        for j in (i + 1)..K {\r\n            assert(positions[i] != positions[j], \"Duplicate draw positions\");\r\n        }\r\n    }\r\n    \r\n    // Verify final consumed count\r\n    assert(\r\n        new_consumed_count == old_consumed_count + K,\r\n        \"Invalid consumed count after multiple draws\"\r\n    );\r\n    \r\n    // Note: Full bitset verification would require sequential bit flips\r\n    // For optimization, caller ensures bitset consistency off-circuit\r\n}\r\n\r\n#[test]\r\nfn test_draw_position_validation() {\r\n    let position: u32 = 50;\r\n    assert(position < DECK_SIZE);\r\n}\r\n\r\n#[test(should_fail_with = \"Draw position out of range\")]\r\nfn test_draw_invalid_position() {\r\n    let position: u32 = 200;\r\n    assert(position < DECK_SIZE, \"Draw position out of range\");\r\n}\r\n\r\n#[test]\r\nfn test_verify_bit_flip() {\r\n    let old: [u1; 8] = [0, 0, 0, 0, 0, 0, 0, 0];\r\n    let new: [u1; 8] = [0, 0, 0, 1, 0, 0, 0, 0];\r\n    \r\n    verify_bit_flip(old, new, 3);\r\n}","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/draw/src/main.nr"},"63":{"source":"// Poseidon hashing utilities for ZK UNO\r\n\r\nuse crate::constants::{DOMAIN_CARD_UID, DOMAIN_CARD_COMMITMENT, DOMAIN_MERKLE_NODE, DOMAIN_BITSET_COMPRESS};\r\n\r\n/// Hash a card to generate unique identifier\r\n/// card_uid = Pedersen(domain || color || type || copy_index)\r\n/// \r\n/// DEPRECATED: Use get_card_uid() from card_uids module instead for better performance\r\n/// This function is kept for testing/validation purposes only\r\npub fn hash_card_uid(color: u8, card_type: u8, copy_index: u8) -> Field {\r\n    let inputs = [\r\n        DOMAIN_CARD_UID,\r\n        color as Field,\r\n        card_type as Field,\r\n        copy_index as Field\r\n    ];\r\n    std::hash::pedersen_hash(inputs)\r\n}\r\n\r\n/// Create card commitment (leaf)\r\n/// commitment = Pedersen(domain || card_uid || nonce)\r\npub fn hash_card_commitment(card_uid: Field, nonce: Field) -> Field {\r\n    std::hash::pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\n}\r\n\r\n/// Hash two Merkle tree nodes\r\n/// node = Pedersen(domain || left || right)\r\npub fn hash_merkle_node(left: Field, right: Field) -> Field {\r\n    std::hash::pedersen_hash([DOMAIN_MERKLE_NODE, left, right])\r\n}\r\n\r\n/// Compress a bitset chunk using Pedersen\r\n/// Used for bitset state commitments\r\npub fn hash_bitset_chunk(bits: [u1; 16]) -> Field {\r\n    // Convert bits to Fields and hash\r\n    let mut fields: [Field; 17] = [0; 17];\r\n    fields[0] = DOMAIN_BITSET_COMPRESS;\r\n    \r\n    for i in 0..16 {\r\n        fields[i + 1] = bits[i] as Field;\r\n    }\r\n    \r\n    // Use Pedersen hash for all fields\r\n    std::hash::pedersen_hash(fields)\r\n}\r\n\r\n/// Iteratively compress a full bitset\r\n/// Takes chunks of bits and builds a commitment tree\r\npub fn compress_bitset<let N: u32>(bits: [u1; N]) -> Field {\r\n    assert(N > 0, \"Bitset cannot be empty\");\r\n    \r\n    // For small bitsets, hash directly\r\n    if N <= 16 {\r\n        let mut chunk: [u1; 16] = [0; 16];\r\n        for i in 0..N {\r\n            chunk[i] = bits[i];\r\n        }\r\n        hash_bitset_chunk(chunk)\r\n    } else {\r\n        // For larger bitsets, recursively hash chunks\r\n        let chunk_count = (N + 15) / 16;  // Ceiling division\r\n        let mut chunk_hashes: [Field; 7] = [0; 7];  // Max 7 chunks for 108 bits\r\n        \r\n        for chunk_idx in 0..chunk_count {\r\n            let start = chunk_idx * 16;\r\n            let end = if start + 16 < N { start + 16 } else { N };\r\n            \r\n            let mut chunk: [u1; 16] = [0; 16];\r\n            for i in 0..(end - start) {\r\n                chunk[i] = bits[start + i];\r\n            }\r\n            \r\n            if chunk_idx < 7 {\r\n                chunk_hashes[chunk_idx] = hash_bitset_chunk(chunk);\r\n            }\r\n        }\r\n        \r\n        // Hash all chunk hashes together\r\n        let mut result = chunk_hashes[0];\r\n        for i in 1..chunk_count {\r\n            if i < 7 {\r\n                result = hash_merkle_node(result, chunk_hashes[i]);\r\n            }\r\n        }\r\n        \r\n        result\r\n    }\r\n}\r\n\r\n/// Aggregate sum of field elements\r\npub fn aggregate_sum<let N: u32>(values: [Field; N]) -> Field {\r\n    let mut sum: Field = 0;\r\n    for i in 0..N {\r\n        sum += values[i];\r\n    }\r\n    sum\r\n}\r\n\r\n/// Aggregate product of field elements with offset to avoid zero\r\npub fn aggregate_product<let N: u32>(values: [Field; N], offset: Field) -> Field {\r\n    let mut product: Field = 1;\r\n    for i in 0..N {\r\n        product *= (offset + values[i]);\r\n    }\r\n    product\r\n}\r\n\r\n#[test]\r\nfn test_hash_card_uid() {\r\n    let uid1 = hash_card_uid(1, 5, 0);  // Red 5, copy 0\r\n    let uid2 = hash_card_uid(1, 5, 1);  // Red 5, copy 1\r\n    let uid3 = hash_card_uid(2, 5, 0);  // Green 5, copy 0\r\n    \r\n    // Different copy indices should give different UIDs\r\n    assert(uid1 != uid2);\r\n    // Different colors should give different UIDs\r\n    assert(uid1 != uid3);\r\n}\r\n\r\n#[test]\r\nfn test_hash_card_commitment() {\r\n    let uid = hash_card_uid(1, 5, 0);\r\n    let nonce1: Field = 12345;\r\n    let nonce2: Field = 54321;\r\n    \r\n    let commit1 = hash_card_commitment(uid, nonce1);\r\n    let commit2 = hash_card_commitment(uid, nonce2);\r\n    \r\n    // Same card with different nonces should give different commitments\r\n    assert(commit1 != commit2);\r\n}\r\n\r\n#[test]\r\nfn test_aggregate_sum() {\r\n    let values: [Field; 5] = [1, 2, 3, 4, 5];\r\n    let sum = aggregate_sum(values);\r\n    assert(sum == 15);\r\n}\r\n\r\n#[test]\r\nfn test_aggregate_product() {\r\n    let values: [Field; 3] = [1, 2, 3];\r\n    let offset: Field = 0;\r\n    let product = aggregate_product(values, offset);\r\n    assert(product == 6);  // 1 * 2 * 3 = 6\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/lib/src/utils/hash.nr"},"64":{"source":"// Merkle tree utilities for ZK UNO\r\n\r\nuse crate::types::{MERKLE_DEPTH, MerkleProof};\r\nuse crate::utils::hash::hash_merkle_node;\r\n\r\n/// Verify a Merkle inclusion proof\r\n/// Proves that a leaf exists at a specific position in the tree\r\npub fn verify_merkle_proof(\r\n    leaf: Field,\r\n    proof: MerkleProof,\r\n    root: Field\r\n) -> bool {\r\n    let mut computed = leaf;\r\n    \r\n    for i in 0..MERKLE_DEPTH {\r\n        if proof.indices[i] == 0 {\r\n            // Leaf is on the left\r\n            computed = hash_merkle_node(computed, proof.path[i]);\r\n        } else {\r\n            // Leaf is on the right\r\n            computed = hash_merkle_node(proof.path[i], computed);\r\n        }\r\n    }\r\n    \r\n    computed == root\r\n}\r\n\r\n/// Assert that a Merkle proof is valid\r\npub fn assert_merkle_proof(\r\n    leaf: Field,\r\n    proof: MerkleProof,\r\n    root: Field\r\n) {\r\n    let valid = verify_merkle_proof(leaf, proof, root);\r\n    assert(valid, \"Invalid Merkle proof\");\r\n}\r\n\r\n/// Verify multiple Merkle proofs against the same root\r\npub fn verify_multiple_proofs<let N: u32>(\r\n    leaves: [Field; N],\r\n    proofs: [MerkleProof; N],\r\n    root: Field\r\n) -> bool {\r\n    let mut all_valid = true;\r\n    \r\n    for i in 0..N {\r\n        let valid = verify_merkle_proof(leaves[i], proofs[i], root);\r\n        all_valid = all_valid & valid;\r\n    }\r\n    \r\n    all_valid\r\n}\r\n\r\n/// Assert multiple Merkle proofs are valid\r\npub fn assert_multiple_proofs<let N: u32>(\r\n    leaves: [Field; N],\r\n    proofs: [MerkleProof; N],\r\n    root: Field\r\n) {\r\n    for i in 0..N {\r\n        assert_merkle_proof(leaves[i], proofs[i], root);\r\n    }\r\n}\r\n\r\n/// Compute Merkle root from a set of leaves (for testing)\r\n/// Note: This is expensive in-circuit and should only be used for small trees\r\nunconstrained pub fn compute_merkle_root<let N: u32>(leaves: [Field; N]) -> Field {\r\n    assert(N > 0, \"Cannot compute root of empty tree\");\r\n    assert(N <= 128, \"Tree too large for MERKLE_DEPTH=7\");\r\n    \r\n    // Pad to next power of 2\r\n    let mut padded_size = 1;\r\n    while padded_size < N {\r\n        padded_size *= 2;\r\n    }\r\n    \r\n    let mut current_level: [Field; 128] = [0; 128];\r\n    \r\n    // Initialize first level with leaves\r\n    for i in 0..N {\r\n        current_level[i] = leaves[i];\r\n    }\r\n    // Pad with zeros\r\n    for i in N..padded_size {\r\n        current_level[i] = 0;\r\n    }\r\n    \r\n    // Build tree bottom-up\r\n    let mut level_size = padded_size;\r\n    while level_size > 1 {\r\n        for i in 0..(level_size / 2) {\r\n            current_level[i] = hash_merkle_node(\r\n                current_level[i * 2],\r\n                current_level[i * 2 + 1]\r\n            );\r\n        }\r\n        level_size /= 2;\r\n    }\r\n    \r\n    current_level[0]\r\n}\r\n\r\n/// Generate a Merkle path for a specific leaf index (for testing)\r\n/// This is used off-circuit to prepare witness data\r\nunconstrained fn generate_merkle_path<let N: u32>(\r\n    leaves: [Field; N],\r\n    leaf_index: u32\r\n) -> MerkleProof {\r\n    assert(leaf_index < N, \"Leaf index out of bounds\");\r\n    assert(N <= 128, \"Tree too large\");\r\n    \r\n    let mut path: [Field; MERKLE_DEPTH] = [0; MERKLE_DEPTH];\r\n    let mut indices: [u1; MERKLE_DEPTH] = [0; MERKLE_DEPTH];\r\n    \r\n    // Pad to next power of 2\r\n    let mut padded_size = 1;\r\n    while padded_size < N {\r\n        padded_size *= 2;\r\n    }\r\n    \r\n    let mut current_level: [Field; 128] = [0; 128];\r\n    for i in 0..N {\r\n        current_level[i] = leaves[i];\r\n    }\r\n    for i in N..padded_size {\r\n        current_level[i] = 0;\r\n    }\r\n    \r\n    let mut current_index = leaf_index;\r\n    let mut level_size = padded_size;\r\n    let mut depth = 0;\r\n    \r\n    while level_size > 1 & depth < MERKLE_DEPTH {\r\n        let sibling_index = if current_index % 2 == 0 {\r\n            current_index + 1\r\n        } else {\r\n            current_index - 1\r\n        };\r\n        \r\n        path[depth] = current_level[sibling_index];\r\n        indices[depth] = (current_index % 2) as u1;\r\n        \r\n        // Build next level\r\n        for i in 0..(level_size / 2) {\r\n            current_level[i] = hash_merkle_node(\r\n                current_level[i * 2],\r\n                current_level[i * 2 + 1]\r\n            );\r\n        }\r\n        \r\n        current_index /= 2;\r\n        level_size /= 2;\r\n        depth += 1;\r\n    }\r\n    \r\n    MerkleProof { path, indices }\r\n}\r\n\r\n#[test]\r\nfn test_merkle_proof_single_leaf() {\r\n    let leaf: Field = 12345;\r\n    let _root = leaf;  // Single leaf tree\r\n    \r\n    let _proof = MerkleProof {\r\n        path: [0; MERKLE_DEPTH],\r\n        indices: [0; MERKLE_DEPTH]\r\n    };\r\n    \r\n    // Note: This test would need to be adjusted based on your Merkle tree construction\r\n    // For a single leaf, the root should equal the leaf\r\n}\r\n\r\n#[test]\r\nfn test_merkle_proof_two_leaves() {\r\n    let leaf0: Field = 100;\r\n    let leaf1: Field = 200;\r\n    \r\n    // Compute root: hash(leaf0, leaf1)\r\n    let root = hash_merkle_node(leaf0, leaf1);\r\n    \r\n    // Proof for first leaf (index 0, left side)\r\n    // Since leaf0 is on the left, we hash: hash(leaf0, leaf1)\r\n    // Path contains siblings at each level\r\n    let proof0 = MerkleProof {\r\n        path: [leaf1, 0, 0, 0, 0, 0, 0],\r\n        indices: [0, 0, 0, 0, 0, 0, 0]  // 0 means leaf is on left\r\n    };\r\n    \r\n    // This should pass: recompute root from leaf0\r\n    // Level 0: hash(leaf0, path[0]) = hash(leaf0, leaf1) = root\r\n    let computed_root = hash_merkle_node(leaf0, proof0.path[0]);\r\n    assert(computed_root == root, \"Manual root computation failed\");\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/lib/src/utils/merkle.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}