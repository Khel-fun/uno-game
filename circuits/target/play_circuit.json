{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"16830535734477690982","abi":{"parameters":[{"name":"game_id","type":{"kind":"field"},"visibility":"public"},{"name":"player_id","type":{"kind":"field"},"visibility":"public"},{"name":"move_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"hand_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"top_card_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"played_card_color","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"played_card_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"played_card_copy","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"played_card_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"played_card_merkle_path","type":{"kind":"struct","path":"zk_uno::types::MerkleProof","fields":[{"name":"path","type":{"kind":"array","length":7,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":1}}}]},"visibility":"private"},{"name":"top_card_color","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"top_card_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"top_card_copy","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"top_card_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"commitment_nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"12504151944586406243":{"error_kind":"string","string":"Invalid Merkle proof"},"14820274075660192021":{"error_kind":"string","string":"Illegal card play"},"15976549250459345174":{"error_kind":"string","string":"Invalid move commitment"},"17714723479599754282":{"error_kind":"string","string":"Top card commitment mismatch"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// Play validation circuit  \r\n// Proves that a card play is legal according to UNO rules\r\n\r\nuse dep::zk_uno::types::{Card, MerkleProof};\r\nuse dep::zk_uno::cards::encoding::{can_play_card, encode_card, decode_card_components};\r\nuse dep::zk_uno::utils::hash::hash_card_commitment;\r\nuse dep::zk_uno::utils::merkle::assert_merkle_proof;\r\nuse dep::zk_uno::card_uids::get_card_uid;\r\n\r\n// Main entry point for the circuit - OPTIMIZED\r\n// Inlines can_play_card logic to avoid function call overhead\r\nfn main(\r\n    // Public inputs\r\n    game_id: pub Field,\r\n    player_id: pub Field,\r\n    move_commitment: pub Field,\r\n    hand_merkle_root: pub Field,\r\n    top_card_commitment: pub Field,\r\n    \r\n    // Private witnesses - played card\r\n    played_card_color: u8,\r\n    played_card_type: u8,\r\n    played_card_copy: u8,\r\n    played_card_nonce: Field,\r\n    played_card_merkle_path: MerkleProof,\r\n    \r\n    // Private witnesses - top card on discard pile\r\n    top_card_color: u8,\r\n    top_card_type: u8,\r\n    top_card_copy: u8,\r\n    top_card_nonce: Field,\r\n    \r\n    // Move commitment nonce\r\n    commitment_nonce: Field\r\n) {\r\n    // OPTIMIZED: Get UIDs directly without creating Card structs\r\n    let played_card_uid = get_card_uid(played_card_color, played_card_type, played_card_copy);\r\n    let top_card_uid = get_card_uid(top_card_color, top_card_type, top_card_copy);\r\n    \r\n    // Verify played card is in player's hand (Merkle proof)\r\n    let played_leaf = hash_card_commitment(played_card_uid, played_card_nonce);\r\n    assert_merkle_proof(played_leaf, played_card_merkle_path, hand_merkle_root);\r\n    \r\n    // Verify top card commitment matches the public discard pile state\r\n    let top_leaf = hash_card_commitment(top_card_uid, top_card_nonce);\r\n    assert(top_leaf == top_card_commitment, \"Top card commitment mismatch\");\r\n    \r\n    // OPTIMIZED: Inline UNO rules validation to avoid function call overhead\r\n    // Wild cards (color 0 or type >= 13) always match\r\n    let played_is_wild = (played_card_color == 0) | (played_card_type >= 13);\r\n    let top_is_wild = (top_card_color == 0) | (top_card_type >= 13);\r\n    let same_color = played_card_color == top_card_color;\r\n    let same_type = played_card_type == top_card_type;\r\n    \r\n    let is_legal = played_is_wild | top_is_wild | same_color | same_type;\r\n    assert(is_legal, \"Illegal card play\");\r\n    \r\n    // Verify move commitment matches\r\n    let computed_commitment = std::hash::pedersen_hash([game_id, player_id, played_card_uid, commitment_nonce]);\r\n    assert(computed_commitment == move_commitment, \"Invalid move commitment\");\r\n}\r\n\r\n/// Prove that a card can be legally played\r\n/// - Card is in player's hand (Merkle proof from hand root)\r\n/// - Card matches top of discard pile (color, number, or wild)\r\n/// - Updates game state correctly\r\npub fn prove_legal_play(\r\n    // Public inputs\r\n    hand_merkle_root: Field,\r\n    top_card_commitment: Field,  // Top of discard pile\r\n    \r\n    // Private witnesses\r\n    played_card: Card,\r\n    played_card_nonce: Field,\r\n    played_card_merkle_path: MerkleProof,\r\n    \r\n    top_card: Card,\r\n    top_card_nonce: Field\r\n) {\r\n    // Verify played card is in player's hand\r\n    let played_card_uid = encode_card(played_card);\r\n    let played_leaf = hash_card_commitment(played_card_uid, played_card_nonce);\r\n    assert_merkle_proof(played_leaf, played_card_merkle_path, hand_merkle_root);\r\n    \r\n    // Verify top card commitment matches\r\n    let top_card_uid = encode_card(top_card);\r\n    let top_leaf = hash_card_commitment(top_card_uid, top_card_nonce);\r\n    assert(top_leaf == top_card_commitment, \"Top card commitment mismatch\");\r\n    \r\n    // Verify the play is legal\r\n    assert(can_play_card(played_card, top_card), \"Illegal card play\");\r\n}\r\n\r\n/// Simplified play validation for testing\r\npub fn verify_card_playable(played_card: Card, top_card: Card) -> bool {\r\n    can_play_card(played_card, top_card)\r\n}\r\n\r\n/// Prove a Wild Draw Four challenge\r\n/// Player claims the previous player had a matching color\r\n/// Must prove they have no cards of the current color\r\npub fn prove_wild_draw_four_challenge(\r\n    _hand_merkle_root: Field,\r\n    current_color: u8,\r\n    hand_cards: [Card; 20],  // MAX_HAND_SIZE\r\n    hand_count: u32\r\n) {\r\n    // Verify none of the cards match the current color\r\n    for i in 0..hand_count {\r\n        if i < 20 {\r\n            let card = hand_cards[i];\r\n            assert(\r\n                (card.color.value != current_color) | card.card_type.is_wild(),\r\n                \"Player has matching color card\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/// Create a move commitment hash for on-chain verification\r\n/// This is compatible with the smart contract's commitMove function\r\npub fn create_move_commitment(\r\n    game_id: Field,\r\n    player_id: Field,\r\n    card_uid: Field,\r\n    nonce: Field\r\n) -> Field {\r\n    // Create a commitment that can be verified on-chain\r\n    std::hash::pedersen_hash([game_id, player_id, card_uid, nonce])\r\n}\r\n\r\n/// Verify a move matches a committed hash\r\npub fn verify_move_commitment(\r\n    commitment: Field,\r\n    game_id: Field,\r\n    player_id: Field,\r\n    card_uid: Field,\r\n    nonce: Field\r\n) {\r\n    let computed = create_move_commitment(game_id, player_id, card_uid, nonce);\r\n    assert(computed == commitment, \"Move commitment mismatch\");\r\n}\r\n\r\n#[test]\r\nfn test_verify_card_playable() {\r\n    let red5 = decode_card_components(1, 5, 0);    // Red 5\r\n    let red7 = decode_card_components(1, 7, 0);    // Red 7\r\n    let blue5 = decode_card_components(3, 5, 0);   // Blue 5\r\n    let blue7 = decode_card_components(3, 7, 0);   // Blue 7\r\n    let wild = decode_card_components(0, 13, 0);   // Wild\r\n    \r\n    // Can play red 7 on red 5 (same color)\r\n    assert(verify_card_playable(red7, red5));\r\n    \r\n    // Can play blue 5 on red 5 (same number)\r\n    assert(verify_card_playable(blue5, red5));\r\n    \r\n    // Cannot play blue 7 on red 5 (different color and number)\r\n    assert(!verify_card_playable(blue7, red5));\r\n    \r\n    // Can play wild on anything\r\n    assert(verify_card_playable(wild, red5));\r\n}\r\n\r\n#[test]\r\nfn test_create_move_commitment() {\r\n    let game_id: Field = 123;\r\n    let player_id: Field = 456;\r\n    let card_uid: Field = 789;\r\n    let nonce: Field = 999;\r\n    \r\n    let commitment1 = create_move_commitment(game_id, player_id, card_uid, nonce);\r\n    let commitment2 = create_move_commitment(game_id, player_id, card_uid, nonce);\r\n    \r\n    // Same inputs should produce same commitment\r\n    assert(commitment1 == commitment2);\r\n    \r\n    // Different nonce should produce different commitment\r\n    let commitment3 = create_move_commitment(game_id, player_id, card_uid, 888);\r\n    assert(commitment1 != commitment3);\r\n}\r\n\r\n#[test]\r\nfn test_verify_move_commitment() {\r\n    let game_id: Field = 100;\r\n    let player_id: Field = 200;\r\n    let card_uid: Field = 300;\r\n    let nonce: Field = 400;\r\n    \r\n    let commitment = create_move_commitment(game_id, player_id, card_uid, nonce);\r\n    verify_move_commitment(commitment, game_id, player_id, card_uid, nonce);\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/play/src/main.nr"},"51":{"source":"// Precomputed canonical card UIDs for all 108 UNO cards\r\n// Generated using Pedersen hash with DOMAIN_CARD_UID = 1\r\n// This eliminates the need for dynamic hashing during proof generation\r\n\r\npub global CANONICAL_DECK_UIDS: [Field; 108] = [\r\n    0x1290bfac1f5b8e4178d73646434a41e8f7ff9104a6c35d5664f53bdb80830310,  // Wild Wild #1\r\n    0x013a589ab9d3d19e4230e8a68fbaadada9c23b2869a7c0447f7c256ad01088b6,  // Wild Wild #2\r\n    0x1a9e724ca1992cb60b2279dad12951ed24e67d95d78cef4caf6fe78299bca912,  // Wild Wild #3\r\n    0x17e36b24f5ca3a76ae0e4678118705a09f3e416f04d9d7a05a3088698f372d54,  // Wild Wild #4\r\n    0x2e5f062dd067914f57b53218bbac079aa6dec20448d0edaff1d513bcf0aee5a5,  // Wild Wild Draw Four #1\r\n    0x1100b6c463af1de4dbc4e304827083f18f6d58d2fcd484fa075066a94b573bc0,  // Wild Wild Draw Four #2\r\n    0x2746d02fec1ab5fa5eac4b39c5053eaaeeb09f0c6bc4917f1dddf7b377c699ca,  // Wild Wild Draw Four #3\r\n    0x0b8a6525904288c33f5499ddbd1c7bf92627fb8cdeff6f4c924ed74a17e5416e,  // Wild Wild Draw Four #4\r\n    0x222ee5a04ba48f8a0467a646f4372eef73d42fd224799a5755c974a34e8ec3e1,  // Red 0\r\n    0x2f2b10afd44e6ae4669191803dc3239edf6d8a67bed69d352fe68e2d58100f7e,  // Red 1 #1\r\n    0x29439ea9ace62a0f0b47f24a9267e48e6a7201039784261629911340552aff11,  // Red 1 #2\r\n    0x1ee693689d1ce275d1dd28e0504d742652ad5d7beaea72a66dfe42110a4ead92,  // Red 2 #1\r\n    0x26584a6ac3dd4ce9f1c23d14d4c4e39d26ad120f0931948ae847134e0c265007,  // Red 2 #2\r\n    0x223e962e21817963b8a1cee3ada90366b44b9f30ad84cf9fa7c2b1a5fd7521c0,  // Red 3 #1\r\n    0x0c03888728a27e192a018c812900593e6419036bfbe6b8e34adb337573262f76,  // Red 3 #2\r\n    0x266faa90338e8bbe989d70f81f3d61d9b2fb2cada2da9161fef11440fdae64e3,  // Red 4 #1\r\n    0x0c1624cb51022d9161451679d537eec4213baa17b9e1f1063690e0f408f692d5,  // Red 4 #2\r\n    0x06913a433afe737a80557fc62a59e33bfd806e8bd3030103a892924d9df889cb,  // Red 5 #1\r\n    0x080d7be3a82cb3b1900c2cf4558bd4ebc72b3fcb941e62686d9dac090d38dae6,  // Red 5 #2\r\n    0x2f37ce6b2d36c17ed073d09404e29618ba2ad6248cd5e0af25981e0a5d84ae93,  // Red 6 #1\r\n    0x06ae31a267f5e55c91e1c645f98044b36443c4902a0c654695e36756f8d111c6,  // Red 6 #2\r\n    0x1d684352e823052b70575a280ceb628755fbeb475de1bc43f4321746267cc861,  // Red 7 #1\r\n    0x2607a893db34277a5841541f9dfd481ba1d8f5a4255f3eeb75c8076fccdc3921,  // Red 7 #2\r\n    0x01602133c874d08c930f605ad45f8baad622906115b981053327def434948ec4,  // Red 8 #1\r\n    0x2b5ae3aa553ada57657e47760844910e2d051a33d6ef1dc5107bcf45e75a9ad8,  // Red 8 #2\r\n    0x0626294da59d482706111727d41ae7349b70e466cff180bde5e3b58ccaed36a0,  // Red 9 #1\r\n    0x04a19d3255132b3e788bafb8c55b53fe6a801fbf9d218b5fb0538ed24d10f85a,  // Red 9 #2\r\n    0x07a603b7f83603368d93fed70224e678a4f2ea67905c08ea8f830b117c434a90,  // Red Skip #1\r\n    0x13781669c99958f0b32c1c7f13d71883fcb8e644bce161bb0996241d83b88d44,  // Red Skip #2\r\n    0x2dee58689aee87035e74d444a497f097732d5be88cfb75ec8f2132e790993068,  // Red Reverse #1\r\n    0x2849f5c79411364ba532f8f914283b9a6ac734ba3b7408dd8a897c93778f4d5c,  // Red Reverse #2\r\n    0x3020c73926650957c028e6d91950538e4ed3a99f9625ca0e88949f367050c0bc,  // Red Draw Two #1\r\n    0x24c11e33441fb9caa443f09a2a2470b67d779fdb3451b4cdd38668a597ba5870,  // Red Draw Two #2\r\n    0x2b252c883ba4a7d26348b33879e93f33ac9d501cf3d364cb3efe4120ba0f27b9,  // Green 0\r\n    0x11b49e3ff31d727b36e082607a071e1bdce5a4b727d6a4df32b182f6346b9cc5,  // Green 1 #1\r\n    0x088e53adeebce3b9777995679b101437ffb7b3fc3f811b90494c3d7d17bdce0d,  // Green 1 #2\r\n    0x19426bff7b997bba6f1a06d3fe9e093ad73cf9c248f2332a2849e0acc065565a,  // Green 2 #1\r\n    0x18f4662962f8c3edb2d986dbbf168483cb65cc451b2d2914c598d5eff4e7ff4b,  // Green 2 #2\r\n    0x2dde0ce3fa30f7c681808fcbbd9ed7de342367fbd010c0f17e8ee288da3e7aed,  // Green 3 #1\r\n    0x2962ef5765172ca2e3b85b27053ba8a16991085acefe0ea8a4eb6353d34a85d3,  // Green 3 #2\r\n    0x2144f906424c801a46ce1635c76224b916c63159316bba28964944155f63b62b,  // Green 4 #1\r\n    0x2b39bf3a96dbc9b7c1aefa769a5f16dddb4229b754830fee56af519cb4ab4fc4,  // Green 4 #2\r\n    0x11c85a28387fe141e031b9c97ea0f56b7caeaed34c27d905e772cebce6c0e2db,  // Green 5 #1\r\n    0x1327d1e42ee3c17aac0dbbfb43928eacad22e9f8f82b99945613e132144583be,  // Green 5 #2\r\n    0x1fc8fcc62c2a5c18680671905c4be345928b2a5f9ddb14b7226a4486362a11d5,  // Green 6 #1\r\n    0x2e94d3b0a5b59c671e0422edee4c0760ece26c6259c614e1985d2521d9c4c75e,  // Green 6 #2\r\n    0x00da6529e6e8f1736c0ed823907455c8f32db4b22197106b0360a26be8dc6a47,  // Green 7 #1\r\n    0x1fa220ea2b5cb82e7e6a509313ac67075dc50991e81c39313092ceefbfb3525a,  // Green 7 #2\r\n    0x085a16de0fc85d336106cfe06200af38b010751694eb57bbed6ef001230d4a74,  // Green 8 #1\r\n    0x20163ec12d57edc34c4ad78f2d4e9a7e720e33e153a1655120fc88c42e6c6675,  // Green 8 #2\r\n    0x220cde14c55e13090c701ee74f40746049c8dfa188c7f30bd6b305a32631be40,  // Green 9 #1\r\n    0x13d22c8f8ee55e599248207c264dcbc1cb0c2a242630f3cd99c8d7ffdb29d049,  // Green 9 #2\r\n    0x08c412ccb41e5778ef355deee4e279b72359cc142b3f2c4ba11db642a69abb33,  // Green Skip #1\r\n    0x0d2bb0027dca6a461e48affebeea6861c6edb23a41910ff5bdf6ef0c5b3a306f,  // Green Skip #2\r\n    0x0f0f87a3a1e2b5ce44b6b5f87954709a28a1ff55624b642f3396121d6665d102,  // Green Reverse #1\r\n    0x0678bd5543dbd1e3562746c5b3d5bb6e7773d7d048ecd2e62a7bc8c6b6e87128,  // Green Reverse #2\r\n    0x15fb9819dff1edeb2fcdf8bc4802cc3f7e755ede2318941901c30ffa7c11c8d8,  // Green Draw Two #1\r\n    0x0d0722799046d6e2f157916385e67d8f1ff1ffca8c8b7e02458f0b501785102b,  // Green Draw Two #2\r\n    0x16fdc654bd0454cb348d8019383358ea909120e4cee03ef58c815a12014a8c6e,  // Blue 0\r\n    0x26f73ce7297872f6d47771e0f1a3ec348da1aa6b9f1ffed620f8eddd7d78258d,  // Blue 1 #1\r\n    0x061b8b7cdb21e015e86c43c1f98dde01753504f0a2c0c31346b5c8a29bf33837,  // Blue 1 #2\r\n    0x1177a0ce9b0816b18702b2faba70d72e2045fc2421b25e21f3cedab1d0880d62,  // Blue 2 #1\r\n    0x1d9cde904eaed346784e960e1b8094b227a4eedf483ff0121d715db690c7f55e,  // Blue 2 #2\r\n    0x062744ab8ac71a6c5bd7f55cf9dfc0a4a93b1568d1e56760aad96cce77e973b0,  // Blue 3 #1\r\n    0x1803a67818f53eac09685ed9cfe2edcb5068909162076435c6b5f6e3b22b3d93,  // Blue 3 #2\r\n    0x1a83ef56abcc32029de9813e5eb957250109f01a89afa940e351a1aeda3fb1ce,  // Blue 4 #1\r\n    0x0d47c98ab97ac0fb69cd70242427d6e441a8f11365e4a8beac0041bad98d4600,  // Blue 4 #2\r\n    0x1beae722011913413c2ed6adab9bc8c777700e8544e19d3f8c589cb935bd6ba5,  // Blue 5 #1\r\n    0x2ef9bfb80db4b87cc9e8530f5b18c91aa1cf9318e91413714081e22ce04f3a01,  // Blue 5 #2\r\n    0x20bd672fd0e741bc1e838838680701d666c2cfdf2a9f8a14b1c274a19206b2d2,  // Blue 6 #1\r\n    0x225ea62c50794f7e090a5ddc56fc0e4ad43829c1e53b07b9c50b0fa64b6d3a6d,  // Blue 6 #2\r\n    0x1464e5a47c96bb4aa227c94f3723425b72eb6159495f4a793a5f269156edd164,  // Blue 7 #1\r\n    0x1ff00599f73f962671811c4885a168497f9135d2adac53d42b18380ffdd86919,  // Blue 7 #2\r\n    0x06881342e305fa00523d875b13ae238fa08170ab35b536013d99f9a7b4bb0dd9,  // Blue 8 #1\r\n    0x05dad0631ea2eadaff56c9ac222ec5bd010de27e95b7a1ab933db8c61a401e90,  // Blue 8 #2\r\n    0x28b1139922a2458c8e518b6cfca2c527886c92a3fa801bc360596858293a145f,  // Blue 9 #1\r\n    0x0a0a0ad648f51907a11cc2906f1a03ae650ba1aa50f1798fe06c484e58e42126,  // Blue 9 #2\r\n    0x0f2ddfa2c0cf8d759d4512d6a906430e8e83f26b46c448e128866322a2e3230e,  // Blue Skip #1\r\n    0x167507194199198efb9bb0d4a0868ee12cbc48c65e9a87cb635f6ac7a949df67,  // Blue Skip #2\r\n    0x159f12afc462a5a9c5615bb2fa14c14010d25095b5b7c717cdec8574eed78564,  // Blue Reverse #1\r\n    0x2fff3e7d28738cff1de833d24ae72f49846d213b6b7fa9699ba2ace43f05d1b6,  // Blue Reverse #2\r\n    0x0821bc45af8c40e332a60dce9af8b060033f7996630f2f689762b10a562f031f,  // Blue Draw Two #1\r\n    0x1ab930b519bf8016b1ef2c0adf7584e7aa57f21a347a20bc5f7fed6e15e64721,  // Blue Draw Two #2\r\n    0x06b319c14a6004a5219b13a8608a06b440def586ebd08b04e76c4047afaaad30,  // Yellow 0\r\n    0x2eae5ad7c83269ba72e64e950a7e66fef524447a87df92b08f0d9558d5e7ec87,  // Yellow 1 #1\r\n    0x16da84b0528ebb6fdd3affc09b759ca54333ef96166d07497e6159956121324b,  // Yellow 1 #2\r\n    0x156fe9804db855ff768da21d5e891eb2f0091c8d223929d9a15e14357f450eae,  // Yellow 2 #1\r\n    0x26ad40cf02c39f499a785a17ba735512312e962bff639ecdc6a1a67c98d0232b,  // Yellow 2 #2\r\n    0x19c91a277c00724de3ff6d6bf80199a585aedcfa5465ec6daccd9e7d304646eb,  // Yellow 3 #1\r\n    0x276df4eb91e82aae60ac5c0042065655e48f2a9a0a385b7c35bcb1218aead7ee,  // Yellow 3 #2\r\n    0x2cfa582be6e6f803ef34024217939a5a993b8f4b9273817692b3f24efed7dc28,  // Yellow 4 #1\r\n    0x07150de48bb2b4e80f9dad267e216d8f6bd10888275fc24909b49c758187a587,  // Yellow 4 #2\r\n    0x11e16f62142e09c38cd84abb5f007d54a3c86d62b22144cc4a24a31a793153be,  // Yellow 5 #1\r\n    0x2f82ac45c96b791a061ba2b041d107681227b2be896a2442fef4032d01bbe46d,  // Yellow 5 #2\r\n    0x15a5319eb0d11591053a00ee79a768703e5a4b78aac109349d748041d62fff30,  // Yellow 6 #1\r\n    0x067f9a3c9aee868ba62e00aff1c6037a3ebf9647ad7e027b54a916f5464028a5,  // Yellow 6 #2\r\n    0x11e08f8ec7d606703777a7c8a9fe4b8f83d1bc396b8d86b7acc38be818d11856,  // Yellow 7 #1\r\n    0x01c64ac9d03c365eab575ec61064243387a1996b5bf0529b868b08228a74c8f0,  // Yellow 7 #2\r\n    0x2e1b98478dfc500ca3b9261be9c253346f0d20df15aa8f9b59cea29a8fbc87b3,  // Yellow 8 #1\r\n    0x265b93da3fb3cec0f40f8135da4f98cd55f42ca5c25be9a60084dc69be9fa69a,  // Yellow 8 #2\r\n    0x2d4e7ec28e5e4e9c77d7f868a353df30024ecdb2c1bcaa29ce49748c8055a935,  // Yellow 9 #1\r\n    0x08f65b0a841fb1d5490efffed27bdfe4abdb04d92ae254628b1603299746187b,  // Yellow 9 #2\r\n    0x05c98b617cf8834daf957e618203987062b506dd2a410e1080981c723a33c0fc,  // Yellow Skip #1\r\n    0x0b7edd1330c0abe6bcb64dbd13b6434a89542b8e834f1ebc21e1aeed658ea959,  // Yellow Skip #2\r\n    0x19efab91db5479bdf598f3d47c25b34cdfa57bed1e3506acda01d36365c9f143,  // Yellow Reverse #1\r\n    0x264de5b51c6667fbc140837cee76398bd9d313069164a4e3b3475b0a30744aa0,  // Yellow Reverse #2\r\n    0x280621fad47400c423d92c26f977c6be2a1eb30d458660492fdb08602852811f,  // Yellow Draw Two #1\r\n    0x1e3ca3ee5b5dbe390e07a82cf1cc281a504b6dd1920b8cf2d07c074bc71889f6   // Yellow Draw Two #2\r\n];\r\n\r\n/// Get card UID from components using precomputed lookup table\r\n/// This is MUCH faster than dynamic hashing (30-40% constraint reduction)\r\npub fn get_card_uid(color: u8, card_type: u8, copy_index: u8) -> Field {\r\n    // Calculate index into CANONICAL_DECK_UIDS array\r\n    // Index formula matches card generation order:\r\n    // - Wild cards: indices 0-7\r\n    // - Colored cards: indices 8-107 (25 cards per color * 4 colors)\r\n    \r\n    let idx = if color == 0 {\r\n        // Wild cards\r\n        if card_type == 13 {\r\n            // Wild: indices 0-3\r\n            copy_index as u32\r\n        } else {\r\n            // Wild Draw Four (type 14): indices 4-7\r\n            4 + (copy_index as u32)\r\n        }\r\n    } else {\r\n        // Colored cards: each color has 25 cards\r\n        let color_offset = 8 + ((color - 1) as u32) * 25;\r\n        \r\n        if card_type == 0 {\r\n            // Zero: first card in color\r\n            color_offset\r\n        } else if card_type <= 9 {\r\n            // Number cards 1-9: 2 copies each\r\n            color_offset + 1 + ((card_type - 1) as u32) * 2 + (copy_index as u32)\r\n        } else {\r\n            // Action cards (Skip=10, Reverse=11, Draw Two=12): 2 copies each\r\n            color_offset + 19 + ((card_type - 10) as u32) * 2 + (copy_index as u32)\r\n        }\r\n    };\r\n    \r\n    CANONICAL_DECK_UIDS[idx]\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/lib/src/card_uids.nr"},"63":{"source":"// Poseidon hashing utilities for ZK UNO\r\n\r\nuse crate::constants::{DOMAIN_CARD_UID, DOMAIN_CARD_COMMITMENT, DOMAIN_MERKLE_NODE, DOMAIN_BITSET_COMPRESS};\r\n\r\n/// Hash a card to generate unique identifier\r\n/// card_uid = Pedersen(domain || color || type || copy_index)\r\n/// \r\n/// DEPRECATED: Use get_card_uid() from card_uids module instead for better performance\r\n/// This function is kept for testing/validation purposes only\r\npub fn hash_card_uid(color: u8, card_type: u8, copy_index: u8) -> Field {\r\n    let inputs = [\r\n        DOMAIN_CARD_UID,\r\n        color as Field,\r\n        card_type as Field,\r\n        copy_index as Field\r\n    ];\r\n    std::hash::pedersen_hash(inputs)\r\n}\r\n\r\n/// Create card commitment (leaf)\r\n/// commitment = Pedersen(domain || card_uid || nonce)\r\npub fn hash_card_commitment(card_uid: Field, nonce: Field) -> Field {\r\n    std::hash::pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\n}\r\n\r\n/// Hash two Merkle tree nodes\r\n/// node = Pedersen(domain || left || right)\r\npub fn hash_merkle_node(left: Field, right: Field) -> Field {\r\n    std::hash::pedersen_hash([DOMAIN_MERKLE_NODE, left, right])\r\n}\r\n\r\n/// Compress a bitset chunk using Pedersen\r\n/// Used for bitset state commitments\r\npub fn hash_bitset_chunk(bits: [u1; 16]) -> Field {\r\n    // Convert bits to Fields and hash\r\n    let mut fields: [Field; 17] = [0; 17];\r\n    fields[0] = DOMAIN_BITSET_COMPRESS;\r\n    \r\n    for i in 0..16 {\r\n        fields[i + 1] = bits[i] as Field;\r\n    }\r\n    \r\n    // Use Pedersen hash for all fields\r\n    std::hash::pedersen_hash(fields)\r\n}\r\n\r\n/// Iteratively compress a full bitset\r\n/// Takes chunks of bits and builds a commitment tree\r\npub fn compress_bitset<let N: u32>(bits: [u1; N]) -> Field {\r\n    assert(N > 0, \"Bitset cannot be empty\");\r\n    \r\n    // For small bitsets, hash directly\r\n    if N <= 16 {\r\n        let mut chunk: [u1; 16] = [0; 16];\r\n        for i in 0..N {\r\n            chunk[i] = bits[i];\r\n        }\r\n        hash_bitset_chunk(chunk)\r\n    } else {\r\n        // For larger bitsets, recursively hash chunks\r\n        let chunk_count = (N + 15) / 16;  // Ceiling division\r\n        let mut chunk_hashes: [Field; 7] = [0; 7];  // Max 7 chunks for 108 bits\r\n        \r\n        for chunk_idx in 0..chunk_count {\r\n            let start = chunk_idx * 16;\r\n            let end = if start + 16 < N { start + 16 } else { N };\r\n            \r\n            let mut chunk: [u1; 16] = [0; 16];\r\n            for i in 0..(end - start) {\r\n                chunk[i] = bits[start + i];\r\n            }\r\n            \r\n            if chunk_idx < 7 {\r\n                chunk_hashes[chunk_idx] = hash_bitset_chunk(chunk);\r\n            }\r\n        }\r\n        \r\n        // Hash all chunk hashes together\r\n        let mut result = chunk_hashes[0];\r\n        for i in 1..chunk_count {\r\n            if i < 7 {\r\n                result = hash_merkle_node(result, chunk_hashes[i]);\r\n            }\r\n        }\r\n        \r\n        result\r\n    }\r\n}\r\n\r\n/// Aggregate sum of field elements\r\npub fn aggregate_sum<let N: u32>(values: [Field; N]) -> Field {\r\n    let mut sum: Field = 0;\r\n    for i in 0..N {\r\n        sum += values[i];\r\n    }\r\n    sum\r\n}\r\n\r\n/// Aggregate product of field elements with offset to avoid zero\r\npub fn aggregate_product<let N: u32>(values: [Field; N], offset: Field) -> Field {\r\n    let mut product: Field = 1;\r\n    for i in 0..N {\r\n        product *= (offset + values[i]);\r\n    }\r\n    product\r\n}\r\n\r\n#[test]\r\nfn test_hash_card_uid() {\r\n    let uid1 = hash_card_uid(1, 5, 0);  // Red 5, copy 0\r\n    let uid2 = hash_card_uid(1, 5, 1);  // Red 5, copy 1\r\n    let uid3 = hash_card_uid(2, 5, 0);  // Green 5, copy 0\r\n    \r\n    // Different copy indices should give different UIDs\r\n    assert(uid1 != uid2);\r\n    // Different colors should give different UIDs\r\n    assert(uid1 != uid3);\r\n}\r\n\r\n#[test]\r\nfn test_hash_card_commitment() {\r\n    let uid = hash_card_uid(1, 5, 0);\r\n    let nonce1: Field = 12345;\r\n    let nonce2: Field = 54321;\r\n    \r\n    let commit1 = hash_card_commitment(uid, nonce1);\r\n    let commit2 = hash_card_commitment(uid, nonce2);\r\n    \r\n    // Same card with different nonces should give different commitments\r\n    assert(commit1 != commit2);\r\n}\r\n\r\n#[test]\r\nfn test_aggregate_sum() {\r\n    let values: [Field; 5] = [1, 2, 3, 4, 5];\r\n    let sum = aggregate_sum(values);\r\n    assert(sum == 15);\r\n}\r\n\r\n#[test]\r\nfn test_aggregate_product() {\r\n    let values: [Field; 3] = [1, 2, 3];\r\n    let offset: Field = 0;\r\n    let product = aggregate_product(values, offset);\r\n    assert(product == 6);  // 1 * 2 * 3 = 6\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/lib/src/utils/hash.nr"},"64":{"source":"// Merkle tree utilities for ZK UNO\r\n\r\nuse crate::types::{MERKLE_DEPTH, MerkleProof};\r\nuse crate::utils::hash::hash_merkle_node;\r\n\r\n/// Verify a Merkle inclusion proof\r\n/// Proves that a leaf exists at a specific position in the tree\r\npub fn verify_merkle_proof(\r\n    leaf: Field,\r\n    proof: MerkleProof,\r\n    root: Field\r\n) -> bool {\r\n    let mut computed = leaf;\r\n    \r\n    for i in 0..MERKLE_DEPTH {\r\n        if proof.indices[i] == 0 {\r\n            // Leaf is on the left\r\n            computed = hash_merkle_node(computed, proof.path[i]);\r\n        } else {\r\n            // Leaf is on the right\r\n            computed = hash_merkle_node(proof.path[i], computed);\r\n        }\r\n    }\r\n    \r\n    computed == root\r\n}\r\n\r\n/// Assert that a Merkle proof is valid\r\npub fn assert_merkle_proof(\r\n    leaf: Field,\r\n    proof: MerkleProof,\r\n    root: Field\r\n) {\r\n    let valid = verify_merkle_proof(leaf, proof, root);\r\n    assert(valid, \"Invalid Merkle proof\");\r\n}\r\n\r\n/// Verify multiple Merkle proofs against the same root\r\npub fn verify_multiple_proofs<let N: u32>(\r\n    leaves: [Field; N],\r\n    proofs: [MerkleProof; N],\r\n    root: Field\r\n) -> bool {\r\n    let mut all_valid = true;\r\n    \r\n    for i in 0..N {\r\n        let valid = verify_merkle_proof(leaves[i], proofs[i], root);\r\n        all_valid = all_valid & valid;\r\n    }\r\n    \r\n    all_valid\r\n}\r\n\r\n/// Assert multiple Merkle proofs are valid\r\npub fn assert_multiple_proofs<let N: u32>(\r\n    leaves: [Field; N],\r\n    proofs: [MerkleProof; N],\r\n    root: Field\r\n) {\r\n    for i in 0..N {\r\n        assert_merkle_proof(leaves[i], proofs[i], root);\r\n    }\r\n}\r\n\r\n/// Compute Merkle root from a set of leaves (for testing)\r\n/// Note: This is expensive in-circuit and should only be used for small trees\r\nunconstrained pub fn compute_merkle_root<let N: u32>(leaves: [Field; N]) -> Field {\r\n    assert(N > 0, \"Cannot compute root of empty tree\");\r\n    assert(N <= 128, \"Tree too large for MERKLE_DEPTH=7\");\r\n    \r\n    // Pad to next power of 2\r\n    let mut padded_size = 1;\r\n    while padded_size < N {\r\n        padded_size *= 2;\r\n    }\r\n    \r\n    let mut current_level: [Field; 128] = [0; 128];\r\n    \r\n    // Initialize first level with leaves\r\n    for i in 0..N {\r\n        current_level[i] = leaves[i];\r\n    }\r\n    // Pad with zeros\r\n    for i in N..padded_size {\r\n        current_level[i] = 0;\r\n    }\r\n    \r\n    // Build tree bottom-up\r\n    let mut level_size = padded_size;\r\n    while level_size > 1 {\r\n        for i in 0..(level_size / 2) {\r\n            current_level[i] = hash_merkle_node(\r\n                current_level[i * 2],\r\n                current_level[i * 2 + 1]\r\n            );\r\n        }\r\n        level_size /= 2;\r\n    }\r\n    \r\n    current_level[0]\r\n}\r\n\r\n/// Generate a Merkle path for a specific leaf index (for testing)\r\n/// This is used off-circuit to prepare witness data\r\nunconstrained fn generate_merkle_path<let N: u32>(\r\n    leaves: [Field; N],\r\n    leaf_index: u32\r\n) -> MerkleProof {\r\n    assert(leaf_index < N, \"Leaf index out of bounds\");\r\n    assert(N <= 128, \"Tree too large\");\r\n    \r\n    let mut path: [Field; MERKLE_DEPTH] = [0; MERKLE_DEPTH];\r\n    let mut indices: [u1; MERKLE_DEPTH] = [0; MERKLE_DEPTH];\r\n    \r\n    // Pad to next power of 2\r\n    let mut padded_size = 1;\r\n    while padded_size < N {\r\n        padded_size *= 2;\r\n    }\r\n    \r\n    let mut current_level: [Field; 128] = [0; 128];\r\n    for i in 0..N {\r\n        current_level[i] = leaves[i];\r\n    }\r\n    for i in N..padded_size {\r\n        current_level[i] = 0;\r\n    }\r\n    \r\n    let mut current_index = leaf_index;\r\n    let mut level_size = padded_size;\r\n    let mut depth = 0;\r\n    \r\n    while level_size > 1 & depth < MERKLE_DEPTH {\r\n        let sibling_index = if current_index % 2 == 0 {\r\n            current_index + 1\r\n        } else {\r\n            current_index - 1\r\n        };\r\n        \r\n        path[depth] = current_level[sibling_index];\r\n        indices[depth] = (current_index % 2) as u1;\r\n        \r\n        // Build next level\r\n        for i in 0..(level_size / 2) {\r\n            current_level[i] = hash_merkle_node(\r\n                current_level[i * 2],\r\n                current_level[i * 2 + 1]\r\n            );\r\n        }\r\n        \r\n        current_index /= 2;\r\n        level_size /= 2;\r\n        depth += 1;\r\n    }\r\n    \r\n    MerkleProof { path, indices }\r\n}\r\n\r\n#[test]\r\nfn test_merkle_proof_single_leaf() {\r\n    let leaf: Field = 12345;\r\n    let _root = leaf;  // Single leaf tree\r\n    \r\n    let _proof = MerkleProof {\r\n        path: [0; MERKLE_DEPTH],\r\n        indices: [0; MERKLE_DEPTH]\r\n    };\r\n    \r\n    // Note: This test would need to be adjusted based on your Merkle tree construction\r\n    // For a single leaf, the root should equal the leaf\r\n}\r\n\r\n#[test]\r\nfn test_merkle_proof_two_leaves() {\r\n    let leaf0: Field = 100;\r\n    let leaf1: Field = 200;\r\n    \r\n    // Compute root: hash(leaf0, leaf1)\r\n    let root = hash_merkle_node(leaf0, leaf1);\r\n    \r\n    // Proof for first leaf (index 0, left side)\r\n    // Since leaf0 is on the left, we hash: hash(leaf0, leaf1)\r\n    // Path contains siblings at each level\r\n    let proof0 = MerkleProof {\r\n        path: [leaf1, 0, 0, 0, 0, 0, 0],\r\n        indices: [0, 0, 0, 0, 0, 0, 0]  // 0 means leaf is on left\r\n    };\r\n    \r\n    // This should pass: recompute root from leaf0\r\n    // Level 0: hash(leaf0, path[0]) = hash(leaf0, leaf1) = root\r\n    let computed_root = hash_merkle_node(leaf0, proof0.path[0]);\r\n    assert(computed_root == root, \"Manual root computation failed\");\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/zunno/Zunno/circuits/lib/src/utils/merkle.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert","directive_integer_quotient"]}